{"version":3,"sources":["../../../../src/query/react/index.ts","../../../../src/query/react/rtkqImports.ts","../../../../src/query/react/module.ts","../../../../src/query/utils/capitalize.ts","../../../../src/query/endpointDefinitions.ts","../../../../src/query/tsHelpers.ts","../../../../src/query/react/buildHooks.ts","../../../../src/query/react/reactImports.ts","../../../../src/query/react/reactReduxImports.ts","../../../../src/query/react/constants.ts","../../../../src/query/react/useSerializedStableValue.ts","../../../../src/query/react/useShallowStableValue.ts","../../../../src/query/react/ApiProvider.tsx"],"sourcesContent":["// This must remain here so that the `mangleErrors.cjs` build script\n// does not have to import this into each source file it rewrites.\nimport { formatProdErrorMessage } from '@reduxjs/toolkit';\nimport { buildCreateApi, coreModule } from './rtkqImports';\nimport { reactHooksModule, reactHooksModuleName } from './module';\nexport * from '@reduxjs/toolkit/query';\nexport { ApiProvider } from './ApiProvider';\nconst createApi = /* @__PURE__ */buildCreateApi(coreModule(), reactHooksModule());\nexport type { TypedUseMutationResult, TypedUseQueryHookResult, TypedUseQueryStateResult, TypedUseQuerySubscriptionResult, TypedLazyQueryTrigger, TypedUseLazyQuery, TypedUseMutation, TypedMutationTrigger, TypedQueryStateSelector, TypedUseQueryState, TypedUseQuery, TypedUseQuerySubscription, TypedUseLazyQuerySubscription, TypedUseQueryStateOptions, TypedUseLazyQueryStateResult, TypedUseInfiniteQuery, TypedUseInfiniteQueryHookResult, TypedUseInfiniteQueryStateResult, TypedUseInfiniteQuerySubscriptionResult, TypedUseInfiniteQueryStateOptions, TypedInfiniteQueryStateSelector, TypedUseInfiniteQuerySubscription, TypedUseInfiniteQueryState, TypedLazyInfiniteQueryTrigger } from './buildHooks';\nexport { UNINITIALIZED_VALUE } from './constants';\nexport { createApi, reactHooksModule, reactHooksModuleName };","export { buildCreateApi, coreModule, copyWithStructuralSharing, setupListeners, QueryStatus, skipToken } from '@reduxjs/toolkit/query';","import { formatProdErrorMessage as _formatProdErrorMessage } from \"@reduxjs/toolkit\";\nimport type { Api, BaseQueryFn, EndpointDefinitions, InfiniteQueryDefinition, Module, MutationDefinition, PrefetchOptions, QueryArgFrom, QueryDefinition, QueryKeys } from '@reduxjs/toolkit/query';\nimport { batch as rrBatch, useDispatch as rrUseDispatch, useSelector as rrUseSelector, useStore as rrUseStore } from 'react-redux';\nimport { createSelector as _createSelector } from 'reselect';\nimport { isInfiniteQueryDefinition, isMutationDefinition, isQueryDefinition } from '../endpointDefinitions';\nimport { safeAssign } from '../tsHelpers';\nimport { capitalize, countObjectKeys } from '../utils';\nimport type { InfiniteQueryHooks, MutationHooks, QueryHooks } from './buildHooks';\nimport { buildHooks } from './buildHooks';\nimport type { HooksWithUniqueNames } from './namedHooks';\nexport const reactHooksModuleName = /* @__PURE__ */Symbol();\nexport type ReactHooksModule = typeof reactHooksModuleName;\ndeclare module '@reduxjs/toolkit/query' {\n  export interface ApiModules<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  BaseQuery extends BaseQueryFn, Definitions extends EndpointDefinitions,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  ReducerPath extends string,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TagTypes extends string> {\n    [reactHooksModuleName]: {\n      /**\n       *  Endpoints based on the input endpoints provided to `createApi`, containing `select`, `hooks` and `action matchers`.\n       */\n      endpoints: { [K in keyof Definitions]: Definitions[K] extends QueryDefinition<any, any, any, any, any> ? QueryHooks<Definitions[K]> : Definitions[K] extends MutationDefinition<any, any, any, any, any> ? MutationHooks<Definitions[K]> : Definitions[K] extends InfiniteQueryDefinition<any, any, any, any, any> ? InfiniteQueryHooks<Definitions[K]> : never };\n      /**\n       * A hook that accepts a string endpoint name, and provides a callback that when called, pre-fetches the data for that endpoint.\n       */\n      usePrefetch<EndpointName extends QueryKeys<Definitions>>(endpointName: EndpointName, options?: PrefetchOptions): (arg: QueryArgFrom<Definitions[EndpointName]>, options?: PrefetchOptions) => void;\n    } & HooksWithUniqueNames<Definitions>;\n  }\n}\ntype RR = typeof import('react-redux');\nexport interface ReactHooksModuleOptions {\n  /**\n   * The hooks from React Redux to be used\n   */\n  hooks?: {\n    /**\n     * The version of the `useDispatch` hook to be used\n     */\n    useDispatch: RR['useDispatch'];\n    /**\n     * The version of the `useSelector` hook to be used\n     */\n    useSelector: RR['useSelector'];\n    /**\n     * The version of the `useStore` hook to be used\n     */\n    useStore: RR['useStore'];\n  };\n  /**\n   * The version of the `batchedUpdates` function to be used\n   */\n  batch?: RR['batch'];\n  /**\n   * Enables performing asynchronous tasks immediately within a render.\n   *\n   * @example\n   *\n   * ```ts\n   * import {\n   *   buildCreateApi,\n   *   coreModule,\n   *   reactHooksModule\n   * } from '@reduxjs/toolkit/query/react'\n   *\n   * const createApi = buildCreateApi(\n   *   coreModule(),\n   *   reactHooksModule({ unstable__sideEffectsInRender: true })\n   * )\n   * ```\n   */\n  unstable__sideEffectsInRender?: boolean;\n  /**\n   * A selector creator (usually from `reselect`, or matching the same signature)\n   */\n  createSelector?: typeof _createSelector;\n}\n\n/**\n * Creates a module that generates react hooks from endpoints, for use with `buildCreateApi`.\n *\n *  @example\n * ```ts\n * const MyContext = React.createContext<ReactReduxContextValue | null>(null);\n * const customCreateApi = buildCreateApi(\n *   coreModule(),\n *   reactHooksModule({\n *     hooks: {\n *       useDispatch: createDispatchHook(MyContext),\n *       useSelector: createSelectorHook(MyContext),\n *       useStore: createStoreHook(MyContext)\n *     }\n *   })\n * );\n * ```\n *\n * @returns A module for use with `buildCreateApi`\n */\nexport const reactHooksModule = ({\n  batch = rrBatch,\n  hooks = {\n    useDispatch: rrUseDispatch,\n    useSelector: rrUseSelector,\n    useStore: rrUseStore\n  },\n  createSelector = _createSelector,\n  unstable__sideEffectsInRender = false,\n  ...rest\n}: ReactHooksModuleOptions = {}): Module<ReactHooksModule> => {\n  if (process.env.NODE_ENV !== 'production') {\n    const hookNames = ['useDispatch', 'useSelector', 'useStore'] as const;\n    let warned = false;\n    for (const hookName of hookNames) {\n      // warn for old hook options\n      if (countObjectKeys(rest) > 0) {\n        if ((rest as Partial<typeof hooks>)[hookName]) {\n          if (!warned) {\n            console.warn('As of RTK 2.0, the hooks now need to be specified as one object, provided under a `hooks` key:' + '\\n`reactHooksModule({ hooks: { useDispatch, useSelector, useStore } })`');\n            warned = true;\n          }\n        }\n        // migrate\n        // @ts-ignore\n        hooks[hookName] = rest[hookName];\n      }\n      // then make sure we have them all\n      if (typeof hooks[hookName] !== 'function') {\n        throw new Error(process.env.NODE_ENV === \"production\" ? _formatProdErrorMessage(36) : `When using custom hooks for context, all ${hookNames.length} hooks need to be provided: ${hookNames.join(', ')}.\\nHook ${hookName} was either not provided or not a function.`);\n      }\n    }\n  }\n  return {\n    name: reactHooksModuleName,\n    init(api, {\n      serializeQueryArgs\n    }, context) {\n      const anyApi = api as any as Api<any, Record<string, any>, any, any, ReactHooksModule>;\n      const {\n        buildQueryHooks,\n        buildInfiniteQueryHooks,\n        buildMutationHook,\n        usePrefetch\n      } = buildHooks({\n        api,\n        moduleOptions: {\n          batch,\n          hooks,\n          unstable__sideEffectsInRender,\n          createSelector\n        },\n        serializeQueryArgs,\n        context\n      });\n      safeAssign(anyApi, {\n        usePrefetch\n      });\n      safeAssign(context, {\n        batch\n      });\n      return {\n        injectEndpoint(endpointName, definition) {\n          if (isQueryDefinition(definition)) {\n            const {\n              useQuery,\n              useLazyQuery,\n              useLazyQuerySubscription,\n              useQueryState,\n              useQuerySubscription\n            } = buildQueryHooks(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useQuery,\n              useLazyQuery,\n              useLazyQuerySubscription,\n              useQueryState,\n              useQuerySubscription\n            });\n            (api as any)[`use${capitalize(endpointName)}Query`] = useQuery;\n            (api as any)[`useLazy${capitalize(endpointName)}Query`] = useLazyQuery;\n          }\n          if (isMutationDefinition(definition)) {\n            const useMutation = buildMutationHook(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useMutation\n            });\n            (api as any)[`use${capitalize(endpointName)}Mutation`] = useMutation;\n          } else if (isInfiniteQueryDefinition(definition)) {\n            const {\n              useInfiniteQuery,\n              useInfiniteQuerySubscription,\n              useInfiniteQueryState\n            } = buildInfiniteQueryHooks(endpointName);\n            safeAssign(anyApi.endpoints[endpointName], {\n              useInfiniteQuery,\n              useInfiniteQuerySubscription,\n              useInfiniteQueryState\n            });\n            (api as any)[`use${capitalize(endpointName)}InfiniteQuery`] = useInfiniteQuery;\n          }\n        }\n      };\n    }\n  };\n};","export function capitalize(str: string) {\n  return str.replace(str[0], str[0].toUpperCase());\n}","import type { Api } from '@reduxjs/toolkit/query';\nimport type { StandardSchemaV1 } from '@standard-schema/spec';\nimport type { BaseQueryApi, BaseQueryArg, BaseQueryError, BaseQueryExtraOptions, BaseQueryFn, BaseQueryMeta, BaseQueryResult, QueryReturnValue } from './baseQueryTypes';\nimport type { CacheCollectionQueryExtraOptions } from './core/buildMiddleware/cacheCollection';\nimport type { CacheLifecycleInfiniteQueryExtraOptions, CacheLifecycleMutationExtraOptions, CacheLifecycleQueryExtraOptions } from './core/buildMiddleware/cacheLifecycle';\nimport type { QueryLifecycleInfiniteQueryExtraOptions, QueryLifecycleMutationExtraOptions, QueryLifecycleQueryExtraOptions } from './core/buildMiddleware/queryLifecycle';\nimport type { InfiniteData, InfiniteQueryConfigOptions, QuerySubState, RootState } from './core/index';\nimport type { SerializeQueryArgs } from './defaultSerializeQueryArgs';\nimport type { NEVER } from './fakeBaseQuery';\nimport type { CastAny, HasRequiredProps, MaybePromise, NonUndefined, OmitFromUnion, UnwrapPromise } from './tsHelpers';\nimport { isNotNullish } from './utils';\nimport type { NamedSchemaError } from './standardSchema';\nimport { filterMap } from './utils/filterMap';\nconst rawResultType = /* @__PURE__ */Symbol();\nconst resultType = /* @__PURE__ */Symbol();\nconst baseQuery = /* @__PURE__ */Symbol();\nexport interface SchemaFailureInfo {\n  endpoint: string;\n  arg: any;\n  type: 'query' | 'mutation';\n  queryCacheKey?: string;\n}\nexport type SchemaFailureHandler = (error: NamedSchemaError, info: SchemaFailureInfo) => void;\nexport type SchemaFailureConverter<BaseQuery extends BaseQueryFn> = (error: NamedSchemaError, info: SchemaFailureInfo) => BaseQueryError<BaseQuery>;\nexport type EndpointDefinitionWithQuery<QueryArg, BaseQuery extends BaseQueryFn, ResultType, RawResultType extends BaseQueryResult<BaseQuery>> = {\n  /**\n   * `query` can be a function that returns either a `string` or an `object` which is passed to your `baseQuery`. If you are using [fetchBaseQuery](./fetchBaseQuery), this can return either a `string` or an `object` of properties in `FetchArgs`. If you use your own custom [`baseQuery`](../../rtk-query/usage/customizing-queries), you can customize this behavior to your liking.\n   *\n   * @example\n   *\n   * ```ts\n   * // codeblock-meta title=\"query example\"\n   *\n   * import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n   * interface Post {\n   *   id: number\n   *   name: string\n   * }\n   * type PostsResponse = Post[]\n   *\n   * const api = createApi({\n   *   baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n   *   tagTypes: ['Post'],\n   *   endpoints: (build) => ({\n   *     getPosts: build.query<PostsResponse, void>({\n   *       // highlight-start\n   *       query: () => 'posts',\n   *       // highlight-end\n   *     }),\n   *     addPost: build.mutation<Post, Partial<Post>>({\n   *      // highlight-start\n   *      query: (body) => ({\n   *        url: `posts`,\n   *        method: 'POST',\n   *        body,\n   *      }),\n   *      // highlight-end\n   *      invalidatesTags: [{ type: 'Post', id: 'LIST' }],\n   *    }),\n   *   })\n   * })\n   * ```\n   */\n  query(arg: QueryArg): BaseQueryArg<BaseQuery>;\n  queryFn?: never;\n  /**\n   * A function to manipulate the data returned by a query or mutation.\n   */\n  transformResponse?(baseQueryReturnValue: RawResultType, meta: BaseQueryMeta<BaseQuery>, arg: QueryArg): ResultType | Promise<ResultType>;\n  /**\n   * A function to manipulate the data returned by a failed query or mutation.\n   */\n  transformErrorResponse?(baseQueryReturnValue: BaseQueryError<BaseQuery>, meta: BaseQueryMeta<BaseQuery>, arg: QueryArg): unknown;\n\n  /**\n   * A schema for the result *before* it's passed to `transformResponse`.\n   *\n   * @example\n   * ```ts\n   * // codeblock-meta no-transpile\n   * import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n   * import * as v from \"valibot\"\n   *\n   * const postSchema = v.object({ id: v.number(), name: v.string() })\n   * type Post = v.InferOutput<typeof postSchema>\n   *\n   * const api = createApi({\n   *   baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n   *   endpoints: (build) => ({\n   *     getPostName: build.query<Post, { id: number }>({\n   *       query: ({ id }) => `/post/${id}`,\n   *       rawResponseSchema: postSchema,\n   *       transformResponse: (post) => post.name,\n   *     }),\n   *   })\n   * })\n   * ```\n   */\n  rawResponseSchema?: StandardSchemaV1<RawResultType>;\n\n  /**\n   * A schema for the error object returned by the `query` or `queryFn`, *before* it's passed to `transformErrorResponse`.\n   *\n   * @example\n   * ```ts\n   * // codeblock-meta no-transpile\n   * import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n   * import * as v from \"valibot\"\n   * import {customBaseQuery, baseQueryErrorSchema} from \"./customBaseQuery\"\n   *\n   * const api = createApi({\n   *   baseQuery: customBaseQuery,\n   *   endpoints: (build) => ({\n   *     getPost: build.query<Post, { id: number }>({\n   *       query: ({ id }) => `/post/${id}`,\n   *       rawErrorResponseSchema: baseQueryErrorSchema,\n   *       transformErrorResponse: (error) => error.data,\n   *     }),\n   *   })\n   * })\n   * ```\n   */\n  rawErrorResponseSchema?: StandardSchemaV1<BaseQueryError<BaseQuery>>;\n};\nexport type EndpointDefinitionWithQueryFn<QueryArg, BaseQuery extends BaseQueryFn, ResultType> = {\n  /**\n   * Can be used in place of `query` as an inline function that bypasses `baseQuery` completely for the endpoint.\n   *\n   * @example\n   * ```ts\n   * // codeblock-meta title=\"Basic queryFn example\"\n   *\n   * import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n   * interface Post {\n   *   id: number\n   *   name: string\n   * }\n   * type PostsResponse = Post[]\n   *\n   * const api = createApi({\n   *   baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n   *   endpoints: (build) => ({\n   *     getPosts: build.query<PostsResponse, void>({\n   *       query: () => 'posts',\n   *     }),\n   *     flipCoin: build.query<'heads' | 'tails', void>({\n   *       // highlight-start\n   *       queryFn(arg, queryApi, extraOptions, baseQuery) {\n   *         const randomVal = Math.random()\n   *         if (randomVal < 0.45) {\n   *           return { data: 'heads' }\n   *         }\n   *         if (randomVal < 0.9) {\n   *           return { data: 'tails' }\n   *         }\n   *         return { error: { status: 500, statusText: 'Internal Server Error', data: \"Coin landed on its edge!\" } }\n   *       }\n   *       // highlight-end\n   *     })\n   *   })\n   * })\n   * ```\n   */\n  queryFn(arg: QueryArg, api: BaseQueryApi, extraOptions: BaseQueryExtraOptions<BaseQuery>, baseQuery: (arg: Parameters<BaseQuery>[0]) => ReturnType<BaseQuery>): MaybePromise<QueryReturnValue<ResultType, BaseQueryError<BaseQuery>, BaseQueryMeta<BaseQuery>>>;\n  query?: never;\n  transformResponse?: never;\n  transformErrorResponse?: never;\n  rawResponseSchema?: never;\n  rawErrorResponseSchema?: never;\n};\ntype BaseEndpointTypes<QueryArg, BaseQuery extends BaseQueryFn, ResultType, RawResultType> = {\n  QueryArg: QueryArg;\n  BaseQuery: BaseQuery;\n  ResultType: ResultType;\n  RawResultType: RawResultType;\n};\nexport type SchemaType = 'arg' | 'rawResponse' | 'response' | 'rawErrorResponse' | 'errorResponse' | 'meta';\ninterface CommonEndpointDefinition<QueryArg, BaseQuery extends BaseQueryFn, ResultType> {\n  /**\n   * A schema for the arguments to be passed to the `query` or `queryFn`.\n   *\n   * @example\n   * ```ts\n   * // codeblock-meta no-transpile\n   * import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n   * import * as v from \"valibot\"\n   *\n   * const api = createApi({\n   *   baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n   *   endpoints: (build) => ({\n   *     getPost: build.query<Post, { id: number }>({\n   *       query: ({ id }) => `/post/${id}`,\n   *       argSchema: v.object({ id: v.number() }),\n   *     }),\n   *   })\n   * })\n   * ```\n   */\n  argSchema?: StandardSchemaV1<QueryArg>;\n\n  /**\n   * A schema for the result (including `transformResponse` if provided).\n   *\n   * @example\n   * ```ts\n   * // codeblock-meta no-transpile\n   * import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n   * import * as v from \"valibot\"\n   *\n   * const postSchema = v.object({ id: v.number(), name: v.string() })\n   * type Post = v.InferOutput<typeof postSchema>\n   *\n   * const api = createApi({\n   *   baseQuery: fetchBaseQuery({ baseUrl: '/' }),\n   *   endpoints: (build) => ({\n   *     getPost: build.query<Post, { id: number }>({\n   *       query: ({ id }) => `/post/${id}`,\n   *       responseSchema: postSchema,\n   *     }),\n   *   })\n   * })\n   * ```\n   */\n  responseSchema?: StandardSchemaV1<ResultType>;\n\n  /**\n   * A schema for the error object returned by the `query` or `queryFn` (including `transformErrorResponse` if provided).\n   *\n   * @example\n   * ```ts\n   * // codeblock-meta no-transpile\n   * import { createApi } from '@reduxjs/toolkit/query/react'\n   * import * as v from \"valibot\"\n   * import { customBaseQuery, baseQueryErrorSchema } from \"./customBaseQuery\"\n   *\n   * const api = createApi({\n   *   baseQuery: customBaseQuery,\n   *   endpoints: (build) => ({\n   *     getPost: build.query<Post, { id: number }>({\n   *       query: ({ id }) => `/post/${id}`,\n   *       errorResponseSchema: baseQueryErrorSchema,\n   *     }),\n   *   })\n   * })\n   * ```\n   */\n  errorResponseSchema?: StandardSchemaV1<BaseQueryError<BaseQuery>>;\n\n  /**\n   * A schema for the `meta` property returned by the `query` or `queryFn`.\n   *\n   * @example\n   * ```ts\n   * // codeblock-meta no-transpile\n   * import { createApi } from '@reduxjs/toolkit/query/react'\n   * import * as v from \"valibot\"\n   * import { customBaseQuery, baseQueryMetaSchema } from \"./customBaseQuery\"\n   *\n   * const api = createApi({\n   *   baseQuery: customBaseQuery,\n   *   endpoints: (build) => ({\n   *     getPost: build.query<Post, { id: number }>({\n   *       query: ({ id }) => `/post/${id}`,\n   *       metaSchema: baseQueryMetaSchema,\n   *     }),\n   *   })\n   * })\n   * ```\n   */\n  metaSchema?: StandardSchemaV1<BaseQueryMeta<BaseQuery>>;\n\n  /**\n   * Defaults to `true`.\n   *\n   * Most apps should leave this setting on. The only time it can be a performance i